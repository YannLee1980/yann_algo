# 算法训练营
[第0周:](#-第0周预备周) <br/>
&emsp;[1.如何高效学习算法训练营课程与纵览](#1如何高效学习算法训练营课程与纵览)<br/>
&emsp;[2.训练准备和复制度分析](#2训练准备和复制度分析)<br/>
[第1周：](#-第1周)<br/>
&emsp;[3.数组、链表、跳表](#第3课数组链表跳表)<br/>
&emsp;[4. 栈、队列、优先队列、双端队列](#第4课-栈队列优先队列双端队列)<br/>
[第2周：](#-第2周)<br/>
&emsp;[5.哈希表、映射、集合：](#第5课哈希表映射集合)<br/>
&emsp;[6.树、二叉树、二叉搜索树的实现和特性](#第6课-树二叉树二叉搜索树的实现和特性)<br/>
[第3周：](#-第3周)<br/>
&emsp;[7.泛型递归、树的递归](#第7课泛型递归树的递归)<br/>
&emsp;[8.分治、回溯](#第8课分治回溯)<br/>
[第4周：](#-第4周)<br/>
&emsp;[9.深度优先和广度优先搜索](#第9课-深度优先和广度优先搜索)<br/>
&emsp;[10.贪心算法](#第10课-贪心算法-)<br/>
&emsp;[11.二分查找](#第11课-二分查找)<br/>
[第6周：](#-第6周)<br/>
&emsp;[12.动态规划](#第12课-动态规划)<br/>
[第7周：](#-第7周)<br/>
&emsp;[13.字典树和并查集](#第13课-字典树和并查集)<br/>
&emsp;[14.字典树和并查集](#第14课-字典树和并查集)<br/>
&emsp;[15.AVL树和红黑树](#第15课-avl树和红黑树)<br/>
[第8周：](#-第8周)<br/>
&emsp;[16.位运算：](#第16课-位运算)<br/>
&emsp;[17.布隆过滤和LRU缓存](#第17课-布隆过滤和lru缓存)<br/>
&emsp;[18.排序算法](#第18课-排序算法)<br/>
[第9周：](#-第9周)<br/>
&emsp;[19.高级动态规划](#第19课-高级动态规划)<br/>
&emsp;[20.字符串算法](#第20课-字符串算法)<br/>
[漂亮代码收集](#漂亮代码收集)<br/>

---
## 第0周：预备周
---
### 1.如何高效学习算法训练营课程与纵览
* 三分看视频理解，七分做练习：
  * 不要死磕； 
  * 敢于放手，敢于死记硬背代码；
  * 不懒于看高手代码；
  * LeetCode题目做5遍。
  
* 数据结构：
  * 一维:
    • 基础:数组 array (string), 链表 linked list
    • 高级:栈 stack, 队列 queue, 双端队列 deque, 集合 set, 映射 map (hash or map), etc
  * 二维:
    • 基础:树 tree, 图 graph
    • 高级:二叉搜索树 binary search tree (red-black tree, AVL), 堆 heap, 并查集 disjoint set, 字典树 Trie, etc
  * 特殊:
    • 位运算 Bitwise, 布隆过滤器 BloomFilter 
    • LRU Cache（缓存）
  
* 算法：
  • If-else, switch —> branch
  • for, while loop —> Iteration
  • 递归 Recursion (Divide & Conquer, Backtrace)
  **以上三条为基本**
  • 搜索 Search: 深度优先搜索 Depth first search, 广度优先搜索 Breadth first search, A*, etc
  • 动态规划 Dynamic Programming
  • 二分查找 Binary Search
  • 贪心 Greedy
  • 数学 Math , 几何 Geometry
  注意:在头脑中回忆上面每种算法的思想和代码模板
  **以上算法的根本是找到重复单元**

* 刻意练习：
  * 刻意练习 — 过遍数(五毒神掌)
  * 练习缺陷、弱点地方
  * 不舒服、不爽、枯燥
  * 训练基本动作

* 反馈：
  • 即时反馈
  • 主动型反馈(自己去找)
    • 高手代码 (GitHub, LeetCode, etc.)
  • 被动式反馈(高手给你指点)
    • code review

* 切题四件套：
  • Clarification（交流明确题目的用意）
  • Possible solutions（所有可能的方法）
    • compare (time/space)
    • optimal(加强) 
  • Coding(多写)
  • Test cases

* 五步刷题法（五毒神掌）：
  1. 第一遍：
     * 5分钟:读题 + 思考
     * 直接看解法:注意!多解法，比较解法优劣 
     * 背诵、默写好的解法
  2. 第二遍：
     * 马上自己写 —> LeetCode 提交
     * 多种解法比较、体会 —> 优化!
  3. 第三遍：
  • 过了一天后，再重复做题
  • 不同解法的熟练程度 —> 专项练习
  4. 第四遍：
  • 过了一周:反复回来练习相同题目
  5. 第五遍：
  • 面试前一周恢复性训练

### 2.训练准备和复制度分析：
* 时间复杂度： Big O notation
  O(1): Constant Complexity 常数复杂度
  O(log n): Logarithmic Complexity 对数复杂度 
  O(n): Linear Complexity 线性时间复杂度
  O(n^2): N square Complexity 平方
  O(n^3): N cubic Complexity 立方
  O(2^n): Exponential Growth 指数
  O(n!): Factorial 阶乘
* 例子：

      O(log(n)):
      for (int i = 1; i < n; i = i * 2) {
        System.out.println("Hey - I'm busy looking at: " + i);
      }
      O(k^n):
      int fib(int n) {
        if (n < 2) return n;
        return fib(n - 1) + fib(n - 2);
      }
*  Master Theorem：

* 以下各算法的时间复杂度：
  二叉树遍历 - 前序、中序、后序:O(N) 
  图的遍历:O(N)
  搜索算法:DFS、BFS - O(N) 
  二分查找:O(logN)
* 空间复杂度：
  1. 数组的长度
  2. 递归的深度(特殊说明)
  实例分析: https://leetcode-cn.com/problems/climbing- stairs/solution/pa-lou-ti-by-leetcode/
* 参考资料：
  >Windows Microsoft New Terminal:https://github.com/microsoft/terminal
  >VS Code Themes:https://vscodethemes.com/
  >教你打造一款颜值逆天的 VS Code:https://toutiao.io/posts/7w5ixl/preview
  >炫酷的 VS Code 毛玻璃效果:https://juejin.im/post/6844903846871842823
  >自顶向下的编程方式:http://markhneedham.com/blog/2008/09/15/clean-code-book-review/c
  >自顶向下编程的 LeetCode 例题:https://leetcode-cn.com/problems/valid-palindrome/

  >参考链接
  如何理解算法时间复杂度的表示法:http://www.zhihu.com/question/21387264
  Master theorem: [Master theorem](http://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))
  主定理: http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86

---
## 第1周：
---
### 第3课：数组、链表、跳表
1. 数组、链表、跳表的基本实现和特性
* Array： 

  | 操作 | 时间复杂度 | 备注 |
  | :---: | :---: | :--- |
  | prepend | O(1) | 在最前面添加，正常情况是O(n)，但现在做了优化，申请的时候会预留较大的区域。
  | append | O(1) |
  | lookup | O(1) |
  | insert | O(n) |
  | delect | O(n) |
  
* Linked List：
    | 操作 | 时间复杂度 | 备注 |
  | :---: | :---: | :--- |
  | prepend | O(1) | 
  | append | O(1) |
  | lookup | O(n) |
  | insert | O(1) |
  | delect | O(1) |
* Skip List:
  注意:只能用于元素有序的情况。
  所以，跳表(skip list)对标的是平衡树(AVL Tree)和二分查找， 是一种 插入/删除/搜索 都是 O(log n) 的数据结构。1989 年出现。
  它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此 在一些热门的项目里用来替代平衡树，如 Redis、LevelDB 等。
  | 操作 | 时间复杂度 | 备注 |
  | :---: | :---: | :--- |
  | prepend | O(1) | 
  | append | O(1) |
  | lookup | O(log n) |
  | insert | O(log n) |
  | delect | O(log n) |
  空间复杂度：O(n)
* 工程中的应用：
  >LRU Cache - Linked list
  https://www.jianshu.com/p/b1ab4a170c3c https://leetcode-cn.com/problems/lru-cache
  Redis - Skip List
  https://redisbook.readthedocs.io/en/latest/internal- datastruct/skiplist.html https://www.zhihu.com/question/20202931
  LevelDB - Skip List
* 小结：
  * 数组、链表、跳表的原理和实现 
  * 三者的时间复杂度、空间复杂度 
  * 工程运用
  * 跳表:升维思想 + 空间换时间
* 参考链接：
  >Java 源码分析（ArrayList）：http://developer.classpath.org/doc/java/util/ArrayList-source.html
  >Linked List 的标准实现代码：https://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/
  >Linked List 示例代码：http://www.cs.cmu.edu/~adamchik/15-121/lectures/Linked%20Lists/code/LinkedList.java
  >Java 源码分析（LinkedList）：http://developer.classpath.org/doc/java/util/LinkedList-source.html
  >LRU Cache - Linked list： LRU 缓存机制：https://leetcode-cn.com/problems/lru-cache/
  >Redis - Skip List：跳跃表、为啥 Redis 使用跳表（Skip List）而不是使用 Red-Black？：https://www.zhihu.com/question/20202931

* 疑惑：
  1. java的内部类，Python有内部类吗？

2. 实战题目解析：移动零
   * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
   * **双指针操作**：

          class Solution:
          def moveZeroes(self, nums: list) -> None:
              """
              Do not return anything, modify nums in-place instead.
              """
              j = 0 
              for i in range(len(nums)):
                  if nums[i] is not 0:
                      nums[j], nums[i] = nums[i], nums[j]
                      j += 1
   * 参考资料：
    >Array 实战题目
    >盛最多水的容器（腾讯、百度、字节跳动在近半年内面试常考）:https://leetcode-cn.com/problems/container-with-most-water/
    >移动零（华为、字节跳动在近半年内面试常考）:https://leetcode-cn.com/problems/move-zeroes/
    >爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考）:https://leetcode-cn.com/problems/climbing-stairs/
    >三数之和（国内、国际大厂历年面试高频老题）:https://leetcode-cn.com/problems/3sum/         
3. 实战题目解析：盛水最多的容器、爬楼梯
   * 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
   * **穷举数列中各数二元组合**：

                for i in range(len(height)-1):
                    for j in range(i+1, len(height)):
                        area = min(height[i], height[j]) * (j - i)
   * **夹逼法向中间靠近**：

            #java:
            class Solution {
                public int maxArea(int[] height) {
                    int max = 0;
                    for(int i = 0, j = height.length - 1; i < j ; ) {
                        int min_height = height[i] < height[j] ? height[i ++] : height[j --];
                        int area = min_height * (j - i + 1);
                        max = Math.max(area, max);
                    }
                    return max;
                }
            }
   * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。(**Fibonacci数列**)
   * **逆向思维（自顶向下）**：

            class Solution:
                def climbStairs(self, n: int) -> int:
                    if n <= 2 :
                        return n
                    if n > 2:
                        f1, f2, f3 = 1, 2, 3
                        for _ in range(3, n+1):
                            f3 = f1 + f2
                            f1 = f2
                            f2 = f3
                        return f3
   * 三数之和：
    **两边夹逼法(三指针的操作，先固定一指针，再夹逼另外两指针)**
   * 强调：
      * 做题一题做5遍；
      * 优化思想：空间换时间，可把一维升为两维；
      * 泛化思维：找最近重复的子问题。
      * 递归思维：递归的时间复杂度是O(2^n)
      * 逆向思维：自顶向下的思维
      * 动态规划
   * Python注意：
      list 的 sorted(): sorted(l) -- 不改变l本身，返回数列；
      list 的 sort(): l.sort() -- 改变l本身，返回None.

    * 参考资料：
    >Linked List 实战题目:
    >反转链表（字节跳动、亚马逊在半年内面试常考）:https://leetcode-cn.com/problems/reverse-linked-list/
    >两两交换链表中的节点（阿里巴巴、字节跳动在半年内面试常考）:https://leetcode-cn.com/problems/swap-nodes-in-pairs/
    >环形链表（阿里巴巴、字节跳动、腾讯在半年内面试常考）:https://leetcode-cn.com/problems/linked-list-cycle/
    >环形链表 II:https://leetcode-cn.com/problems/linked-list-cycle-ii/
    >K 个一组翻转链表（字节跳动、猿辅导在半年内面试常考）:https://leetcode-cn.com/problems/reverse-nodes-in-k-group/

### 第4课. 栈、队列、优先队列、双端队列：
1. 栈和队列的实现与特性：
  * Stack:先入后出;添加、删除皆为 O(1)
  * Queue:先入先出;添加、删除皆为 O(1)
  * Deque:简单理解:- double ended queue(两端可以进出Queue),插入和删除都是 O(1) 操作.
  * python 的 deque： collections包

* 参考链接
  >Java 的 PriorityQueue 文档:https://docs.oracle.com/javase/10/docs/api/java/util/PriorityQueue.html
  >Java 的 Stack 源码:http://developer.classpath.org/doc/java/util/Stack-source.html
  >Java 的 Queue :(http://fuseyism.com/classpath/doc/java/util/Queue-source.html)
  >Python 的 heapq:https://docs.python.org/2/library/heapq.html
  >高性能的 container 库:https://docs.python.org/2/library/collections.html

2. 实战题目解析：有效的括号、最小栈等问题
  * **用栈解决问题**：有效的括号、柱状图中最大的矩形
  * **双栈解决问题**，减少使用空间：最小栈
  * 预习题目
  有效的括号（亚马逊、JPMorgan 在半年内面试常考）
  最小栈（亚马逊在半年内面试常考）
  * 实战题目
  柱状图中最大的矩形（亚马逊、微软、字节跳动在半年内面试中考过）
  滑动窗口最大值（亚马逊在半年内面试常考）
  * 课后作业
  用 add first 或 add last 这套新的 API 改写 Deque 的代码
  分析 Queue 和 Priority Queue 的源码
  设计循环双端队列（Facebook 在 1 年内面试中考过）
  接雨水（亚马逊、字节跳动、高盛集团、Facebook 在半年内面试常考）

### 疑问：
   1.   滑动窗口最大值：https://leetcode-cn.com/problems/sliding-window-maximum/
   2.   环形链表 II: https://leetcode-cn.com/problems/linked-list-cycle-ii/
   3.   K 个一组翻转链表: https://leetcode-cn.com/problems/reverse-nodes-in-k-group/

---
## 第2周：
---
### 第5课.哈希表、映射、集合：
1. 哈希表、映射、集合的特性：
   * O(1)
   * 参考链接
  >Java Set 文档: https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html
  >Java Map 文档: https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html
2. 实战题目解析：有效的字母异位词等问题:
   * 排序的时间复杂度：O(NlogN)
   * collections.defaultdict(list)的使用--value为list
   * 实战题目 / 课后作业
    >有效的字母异位词（亚马逊、Facebook、谷歌在半年内面试中考过）
    >字母异位词分组（亚马逊在半年内面试中常考）
    >两数之和（亚马逊、字节跳动、谷歌、Facebook、苹果、微软、腾讯在半年内面试中常考）
    >参考链接
    >养成收藏精选代码的习惯（示例）:http://shimo.im/docs/R6g9WJV89QkHrDhr

### 第6课 树、二叉树、二叉搜索树的实现和特性：
1. 树、二叉树、二叉搜索树的实现和特性：
  * 二叉搜索树：左节点<根节点<右节点
  * 参考链接
  >二叉搜索树 Demo ： https://visualgo.net/zh/bst
  * 思考题
  >树的面试题解法一般都是递归，为什么？
  >说明：递归可简化代码的维护，并且处理得当并不会消耗比非递归方法太大的复杂度。

2. 实战题目解析：二叉树的中序遍历
   * 合理的使用递归其实效率并不会低下
   *  Linked List 是特殊化的 Tree Tree 是特殊化的Graph

          class TreeNode:
            def __init__(self, val=0, left=None, right=None):
              self.val = val
              self.left = left
              self.right = right
   * 1.前序(Pre-order):根-左-右 

          def preorder(self, root):
            if root:
              self.traverse_path.append(root.val)
              self.preorder(root.left)
              self.preorder(root.right)
   * 2.中序(In-order):左-根-右 

          def inorder(self, root):
            if root:
              self.inorder(root.left)
              self.traverse_path.append(root.val)
              self.inorder(root.right)
   * 3.后序(Post-order):左-右-根

          def postorder(self, root):
            if root:
              self.postorder(root.left)
              self.postorder(root.right)
              self.traverse_path.append(root.val)
   * 参考链接
      树的遍历 Demo
      实战题目 / 课后作业
      二叉树的中序遍历（亚马逊、微软、字节跳动在半年内面试中考过）
      二叉树的前序遍历（谷歌、微软、字节跳动在半年内面试中考过）
      N 叉树的后序遍历（亚马逊在半年内面试中考过）
      N 叉树的前序遍历（亚马逊在半年内面试中考过）
      N 叉树的层序遍历
3. 堆和二叉堆:
    * 二叉堆是由完全二叉树建成的，并通过数组来进行存储的，二叉堆堆效率在堆里是最低的。
    * priority_queue(优先队列)本质就是堆:
      `Python: queue.PriorityQueue、 asyncio.PriorityQueue`（底层是headpq）、 `heapq`
4. 实战题目解析：最小的k个数、滑动窗口最大值等问题：
  * 实战例题
    >最小的 k 个数（字节跳动在半年内面试中考过）
    >滑动窗口最大值（亚马逊在半年内面试中常考）
    >课后作业
    >HeapSort ：自学 https://www.geeksforgeeks.org/heap-sort/
    >丑数（字节跳动在半年内面试中考过）
    >前 K 个高频元素（亚马逊在半年内面试中常考）

5. 图的实现和特性:
   * 广度优先：

          # 代码模版：（用队列）
          def bfs(grid, start):
            queue = []
            visited = set()  ## 注意：要用集合，用了列表会重复遍历
            queue.append(start)
            visited.add(start)
            while queue:
              node = queue.pop(0)
              process(node)
              nodes = generate_related_nodes(node)
              for node in nodes:
                if node not in visited:
                  queue.append(node)
                  visited.add(node)

          # 优化(分层显示)-例子：
          # Definition for a Node.
          class Node:
              def __init__(self, val=None, children=None):
                  self.val = val
                  self.children = children
          """
          import collections
          class Solution:
              def levelOrder(self, root: 'Node') -> List[List[int]]:
                  if root is None:
                      return []
                  
                  result = []
                  deque = collections.deque([root])

                  while deque:
                      level = []
                      for _ in range(len(deque)):
                          node = deque.popleft()
                          level.append(node.val)
                          deque.extend(node.children)
                      result.append(level)

                  return result



   * 深度优先：

          # 代码模版：（用栈）
          def dfs(grid, start):
            stack = []
            visited = set()  ## 注意：要用集合，用了列表会重复遍历
            stack.append(start)
            visited.add(start)
            while stack:
              node = stack.pop()
              process(node)
              nodes = generate_related_nodes(node)
              for node in nodes:
                if node not in visited:
                  stack.append(node)
                  visited.add(node)
                
            # 代码模版：（递归）
            visited = set()
            def dfs(node, visited):
              if node in visited:
                return
              visited.add(node)
              for next_node in node.children():
                dfs(next_node, visited)
   * python heaqp（堆）的使用：小顶堆，可以用l = [], 初始化：`heap = []  heappush(heap, 1)`
   * 参考链接
      >连通图个数： https://leetcode-cn.com/problems/number-of-islands/
      >拓扑排序（Topological Sorting）： https://zhuanlan.zhihu.com/p/34871092
      >最短路径（Shortest Path）：Dijkstra https://www.bilibili.com/video/av25829980?from=search&seid=13391343514095937158
      >最小生成树（Minimum Spanning Tree）： https://www.bilibili.com/video/av84820276?from=search&seid=17476598104352152051

---
## 第3周：
---
### 第7课.泛型递归、树的递归：
1. 递归的实现、特性以及思维要点：
   * 递归与盗梦空间：
      * 向下进入到不同梦境中;
      * 向上又回到原来一层 通过声音同步回到上一层：
      * 每一层的环境和周围的人都是一份拷贝、 主角等几个人穿越不同层级的梦境(发生和携带变化)。
   * 递归的代码模版：

        def recursion(level, param1, param2, ...):
          # recursion terminator:------递归终止条件
          if level > MAX_LEVEL:
            process_result
            return
          
          # process logic in current level:------处理当前层，注意此处可设置处理后的返回值
          process(level, data)

          # drill down to next level:------下探到下一层
          self.recursion(level+1, param1, param2, ...)

          # reverse the current level status if needed------清理当前层，如果有必要
   * 递归注意点：
      * 不要人肉进行递归(最大误区) -- 熟悉递归结构
      * 找到最近最简方法，将其拆解成可重复解决的问题(重复子问题)--**最近重复子问题**
      * 数学归纳法思维：`n = 1, n= 2 成立` -> `n = k 成立`
   * 参考资料：
      >实战题目
      爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考）
      括号生成 (字节跳动在半年内面试中考过)
      翻转二叉树 (谷歌、字节跳动、Facebook 在半年内面试中考过)
      验证二叉搜索树（亚马逊、微软、Facebook 在半年内面试中考过）
      二叉树的最大深度（亚马逊、微软、字节跳动在半年内面试中考过）
      二叉树的最小深度（Facebook、字节跳动、谷歌在半年内面试中考过）
      二叉树的序列化与反序列化（Facebook、亚马逊在半年内面试常考）
      课后作业
      二叉树的最近公共祖先（Facebook 在半年内面试常考）
      从前序与中序遍历序列构造二叉树（字节跳动、亚马逊、微软在半年内面试中考过）
      组合（微软、亚马逊、谷歌在半年内面试中考过）
      全排列（字节跳动在半年内面试常考）
      全排列 II （亚马逊、字节跳动、Facebook 在半年内面试中考过）

### 第8课.分治、回溯：
1. 分治、回溯的实现和特性:
   * 重复性：
      最近重复性--分治、回溯；
      最优重复性--动态规划；
   * 分治：分成子问题->分别处理—>问题合并  
      当层只做当层的事情，不插足下一层的事情

            def divide_conquer(problem, param1, param2, ...): 
            # recursion terminator 
            if problem is None: 
               print_result 
               return 

            # prepare data 
            data = prepare_data(problem) 
            subproblems = split_problem(problem, data) 

            # conquer subproblems 
            subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
            subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
            subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
            …

            # process and generate the final result 
            result = process_result(subresult1, subresult2, subresult3, …)
               
            # revert the current level states
   * 回溯：  回到之前<-不成功<-尝试->成功->继续
2. 实战题目解析：Pow(x,n)、子集:
   * 实战题目
   Pow(x, n) （Facebook 在半年内面试常考）
   子集（Facebook、字节跳动、亚马逊在半年内面试中考过）
   >参考链接
   牛顿迭代法原理: http://www.matrix67.com/blog/archives/361
   牛顿迭代法代码: http://www.voidcn.com/article/p-eudisdmk-zm.html
3. 实战题目解析：电话号码的字母组合、N皇后:
         实战题目
      多数元素 （亚马逊、字节跳动、Facebook 在半年内面试中考过）:https://leetcode-cn.com/problems/majority-element/description/
      电话号码的字母组合（亚马逊在半年内面试常考）:https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
      N 皇后（字节跳动、苹果、谷歌在半年内面试中考过）:https://leetcode-cn.com/problems/n-queens/


#### **Python语法注意：**
* list中的append() VS. extend():
      append():添加成员；
      extend():两数列合并。
* 数列的下标：


            a = [1]
            a[:0] -> []
            a[1:] -> []
            a[1] -> Exception
            a[2:] -> []
#### **对代码对一些理解：**
* 递归里对全排列：

            class Solution:
               def _generate(self, level, max, s):
                  if level >= max:
                        print(s)
                        return None
                  self._generate(level+1, max, s + '(') # （1）
                  self._generate(level+1, max, s + ')') # （2）

               def generateParenthesis(self, n: int):
                  self._generate(0, n, '')
                  
            s = Solution()
            s.generateParenthesis(2)
   >理解：self._generate(0, n, '')中的n可理解为n个格子，每个格子存放'('或')',共有多少种放法。
   >(1)(2)两行代码共计算2^n次。

---
## 第4周：
---
### 第9课 深度优先和广度优先搜索：
1. 深度优先搜索、广度优先搜索的实现和特性：
   * 对于节点的访问顺序不限
     - 深度优先:depth first search
     - 广度优先:breadth first search
     - 优先级优先： 启发式搜索（估价函数）
   * DFS代码模版：

            # 递归写法v1.0:
            visited = set()
            def dfs(node, visited):
               if node in visited: # terminator
                  # node already visited
                  return
               visited.add(node)
               # process current node here
               ...
               for next_node in node.children:
                  if next_node not in visited:
                     dfs(next_node, visited)

            # 递归写法v2.0:
            visted = set()
            def dfs(node, visited):
               visited.add(node)
               # process current node here
               for next_node in node.children:
                  if next_node not in visited:
                     dfs(next_node, visited)
                  
            # 非递归写法：
            def DFS(self, tree):
               if tree is None:
                  return None
               visited, stack = [], [tree.root]
               while stack:
                  node = stack.pop()
                  visited.add(node)
                  process(node)
                  nodes = generate_related_nodes(node)
                  stack.push(nodes)
               # orther processing work
               
   * BFS代码模版：

            def BFS(graph, start, end):
               queue = []
               visited = set()
               queue.push([start])
               while queue:
                  node = queue.pop()
                  visited.add(node)
                  process(node)
                  nodes = generate_related_nodes(node)
                  queue.push(nodes)
               # orther processing work
   * 参考资料：
      实战题目
      二叉树的层序遍历（字节跳动、亚马逊、微软在半年内面试中考过）
      最小基因变化 # 
      括号生成（字节跳动、亚马逊、Facebook 在半年内面试中考过）
      在每个树行中找最大值（微软、亚马逊、Facebook 在半年内面试中考过）
      课后作业
      单词接龙（亚马逊在半年内面试常考）# **未完成**
      单词接龙 II （微软、亚马逊、Facebook 在半年内面试中考过）# **未完成**
      岛屿数量（近半年内，亚马逊在面试中考查此题达到 350 次）
      扫雷游戏（亚马逊、Facebook 在半年内面试中考过）# 未完成 **未完成**
### 第10课 贪心算法 ：
1.贪心的实现、特性及实战题目解析：
   * 贪心算法 VS.回溯 VS.动态规划：
     贪心算法：当下局部最优，不可回退；
     回溯：可回退；
     动态规划：最优判断+回退（保存当前的结果）
   * 贪心算法的使用场景：
     简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终 问题的最优解。这种子问题最优解称为最优子结构。
### 第11课 二分查找：
* 二分查找的实现、特性及实战题目解析：
   * 二分查找的前提：
    1. 目标函数单调性(单调递增或者递减) 
    2. 存在上下界(bounded)
    3. 能够通过索引访问(index accessible)
   * 代码模版：

         left , right = 0 , len(arr) - 1
         while left <= right:    ####注意<=
            mid = (left + right) / 2
            if arr[mid] == target:
               # find the target!!
               break or return
            elif arr[mid] < target:
               left = mid + 1
            else:
               right = mid - 1
     **注意<=**
  
> 参考链接
二分查找代码模板
Fast InvSqrt() 扩展阅读
实战题目
x 的平方根（字节跳动、微软、亚马逊在半年内面试中考过）
有效的完全平方数（亚马逊在半年内面试中考过）
课后作业
搜索旋转排序数组（Facebook、字节跳动、亚马逊在半年内面试常考）
搜索二维矩阵（亚马逊、微软、Facebook 在半年内面试中考过）
寻找旋转排序数组中的最小值（亚马逊、微软、字节跳动在半年内面试中考过）
使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方
说明：同学们可以将自己的思路、代码写在学习总结中
参考链接
牛顿迭代法原理： http://www.matrix67.com/blog/archives/361
牛顿迭代法代码： http://www.voidcn.com/article/p-eudisdmk-zm.html

#### **Python语法注意：**
* for _ in range(len(queue)) 与 for _ in queue 的区别：
  （1）len(queue)是定值， for的循环次数固定； 
  （2）for _ in queue：循环次数随着queue的变化而变化。
#### **对代码对一些理解：**
* 牛顿法求C的算术平方根：
  $$x_{i+1}=\frac12(x_i+\frac{C}{x_i})$$
  x的初始值：一般取C

* 以下两个写法的区别：

            # 如果left、right很大时会溢出：
            mid = (left + right) // 2

            # 防止left、right很大时溢出：
            mid = left + (right - left) // 2

#### **需要理解的地方：**
* 二分查找中的left < right ，何时有=，何时没有=。
* 127、126单词接龙需要进一步理解:
   注意：1.return level是否加1；
      2.去掉visited；
      3.用queue与dict的区别。

---
## 第6周：
---
### 第12课 动态规划：
1. 动态规划的实现及关键点：
   * 改变习惯：
      1. 人肉递归低效、很累
      2. 找到最近最简方法，将其拆解成可重复解决的问题 
      3. 数学归纳法思维(抵制人肉递归的诱惑)
   * 动态规划（Dynamic Programming）----直译：动态递推编程
      1.Wiki 定义: https://en.wikipedia.org/wiki/Dynamic_programming
      2.“Simplifying a complicated problem by breaking it down into simpler sub-problems”(in a recursive manner)
      3.Divide & Conquer + Optimal substructure 分治 + 最优子结构
   * 关键点：
      动态规划 和 递归或者分治 没有根本上的区别(关键看有无最优的子结构)
      共性:找到重复子问题 差异性:最优子结构、中途可以淘汰次优解
2. DP例题解析：Fibonacci数列、路径计数:
   * Fibonacci数列：

            # 递归：
            def fib(n):
               reutrn n if n <= 1 else fib(n-1)+fib(n-2)

            # 记忆化搜索：（自顶向下）
            def fib(n, mome):
               if n <= 1:
                  return n
               if mome[n] == 0:
                  mome[n] = fib(n-1) + fib(n-2)
               return mome[n]

            # 动态递推（自底向上）：----最好习惯于这种
            def fib(n):
               a = [0] * (n+1)
               a[0], a[1] = 0, 1
               for i in range(len(a)):
                  a[i] = a[i-1] + a[i-2]
               return a[n]
      最好习惯于：**动态递推（自底向上）----动态规划**
   * 动态规划关键点：
      1. 最优子结构：`opt[n] = best_of(opt[n-1],opt[n-2],...)`
      2. 存储中间状态：`opt[i]`
      3. 递归方程(状态转移方程、动态规划方程、DP方程）
         如：`Fib: opt[n] = opt[n-1] + opt[n-2]`
            `二维路径：opt[i,j] = opt[i,j+1] + opt[i+1,j]( 且判断a[i,j]是否为空地)`

            # 完整逻辑：
            if opt[i,j] == '空地':
               opt[i,j] = opt[i,j+1] + opt[i+1,j]
            else:
               opt[i,j] = 0
3. DP例题解析：最长公共子序列：
   * 五步解决DP问题：
      1. 定义子问题；
      2. 猜想递归方程；
      3. 解决最近子问题；
      4. 记忆递归或自底向上的递推；
      5. 解决总体问题。
   * 优化3步：
      1. 找最近重复性（即最近子问题）；
      2. 定义状态数组；
      3. DP方程。
4. 实战题目解析：三角形最小路径和:
   * 爬楼梯的变形：
      1. 每步可以走1、2、3级；
      2. 相邻的两步的步伐不一样。
   * 120. 三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
      分析：
      * 最近子问题：problem[i,j] = min(sub[i+1, j] , sub[i+1, j+1]) + a[i,j]
      * 状态数组：自底向上记录最小路径：f[i,j]
      * DP方程：自底向上：f[i,j] = min(f[i+1,j], f[i+1, j+1]) + a[i,j]


5. 实战题目解析：最大子序列和
   * 最大子序和,给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
   示例:
   输入: [-2,1,-3,4,-1,2,1,-5,4]
   输出: 6
   解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
   分析：
     * 暴力：2^n;
     * DP:
      a. 子问题：max_sum(i) = max(a(i), max_sum(i-1)+a(i))
      b. 存储状态定义：f(i):记录包括第i个元素后第最大子序列和 -> 所以题目的最终值是max(f)
      c. DP方程：f(i) = max(a(i), f(i-1)+a(i))

   * 322. 零钱兑换----给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。
   DP方程：f(n) = min(f(n - k) for k in [1, 2, 5]) + 1 或 f(n) = min(f(n - k)+1 for k in [1, 2, 5])

6. 实战题目解析：打家劫舍:
* 198. 打家劫舍--你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
  存储状态：a[i][0,1]:到第i个房子偷盗的最大金额数,该房被偷：a[i][1]，该房没被偷:a[i][0]；初始值：a[0][0]=0, a[0][1]=nums[0]
  DP方程：

            # DP+2维数组：
            a[i][0] = max(a[i-1][0], a[i-1][1])
            a[i][1] = a[i-1][0] + nums[i]

            # DP + 1维数组：
            # a[i] 存储到第i个房子第最大偷取金钱，并不管它有没有被偷。
            a[i] = max(a[i-1], a[i-2]+nums[i])
            # 初始值：
            a[0] = 0
            a[1] = max(nums[0], nums[1])

            # DP + 2数值：
            pre = 0
            now = 0
            now, pre = max(now, pre+nums[i]), now
* 213. 打家劫舍 II----你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
  **转化成上一问题：把nums分成nums[1:]和nums[:-1]并分别用上面第方法解决，然后取两个结果的最大值。**

#### **Python语法注意：**
   * 嵌套列表的创建一定要用推导式：

            # 错误写法：
            a = [[0]*2] * 3

            # 正确写法：
            a = [[0]*2 for _ in range(3)]

            # 验证：
            a[0][0] = 9
            b[0][0] = 9
            #  a： [[9, 0], [0, 0], [0, 0]], 
            #  b:  [[9, 0], [9, 0], [9, 0]]

            # 一维的时候，可以：
            a = [0] * 10
   * lru_cache的使用：

# DFS + 记忆 + LRU_cache
      from functools import lru_cache
      class Solution:
         def minimumTotal(self, triangle: List[List[int]]) -> int:
            @lru_cache(maxsize=None)
            def dfs(i, j):
                  if i == len(triangle) - 1:
                     return triangle[i][j]
                  left = dfs(i+1, j)
                  right = dfs(i+1, j+1)
                  return min(left, right) + triangle[i][j]
            
            return dfs(0, 0)
#### **对代码对一些理解：**
* 123. 买卖股票的最佳时机 III----给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

            # DP + 二维数组存储状态
            class Solution:
               def maxProfit(self, prices: List[int]) -> int:
                  n = len(prices)
                  if n < 2: return 0
                  dp = [[0] * 5 for _ in range(n)] # 记录每天五种状态下的最大获利
                  dp[0][0] = 0 # 不操作
                  dp[0][1] = -prices[0] # 第一次买入
                  dp[0][2] = 0 # 第一次卖出
                  dp[0][3] = -prices[0] # 第二次买入
                  dp[0][4] = 0 # 第二次卖出
                  for i in range(1, n):
                        dp[i][0] = dp[i-1][0] # 不操作
                        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 
                        dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
                        dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
                        dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
                        
                  # 最大值只发生在不持股的时候，因此来源有 3 个：j = 0 ,j = 2, j = 4
                  return max(dp[-1][0], dp[-1][2], dp[-1][4])
   **注意：各状态的存储**

            # DP + 一维数组存储状态
            class Solution:
               def maxProfit(self, prices: List[int]) -> int:
                  n = len(prices)
                  if n < 2: return 0
                  dp = [0] * 5 # 记录当天五种状态下的最大获利
                  # 初始化：
                  dp[0] = 0 # 不操作
                  dp[1] = -prices[0] # 第一次买入
                  dp[2] = 0 # 第一次卖出
                  dp[3] = -prices[0] # 第二次买入
                  dp[4] = 0 # 第二次卖出
                  
                  for i in range(1, n):
                        dp[0] = 0 # 不操作
                        dp[1] = max(dp[1], dp[0] - prices[i]) 
                        dp[2] = max(dp[2], dp[1] + prices[i])
                        dp[3] = max(dp[3], dp[2] - prices[i])
                        dp[4] = max(dp[4], dp[3] + prices[i])
                        
                  # 最大值只发生在不持股的时候，因此来源有 3 个：j = 0 ,j = 2, j = 4
                  return max(dp)

---
## 第7周：
---
### 第13课 字典树和并查集：
1. Trie树(前缀树)的基本实现和特性：
    * 基本性质：
      1. 结点本身不存完整单词;
      2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的 字符串;
      3. 每个结点的所有子结点路径代表的字符都不相同。
    * 内部结构：
    ![avatar](Trie.png)
    * Python代码模版:

                class Trie:

                    def __init__(self):
                        """
                        Initialize your data structure here.
                        """
                        self.root = {}
                        self.end_of_word = "#"

                    def insert(self, word: str) -> None:
                        """
                        Inserts a word into the trie.
                        """
                        node = self.root
                        for ch in word:
                            node = node.setdefault(ch, {})
                        node[self.end_of_word] = self.end_of_word

                    def search(self, word: str) -> bool:
                        """
                        Returns if the word is in the trie.
                        """
                        node = self.root
                        for ch in word:
                            if ch not in node:
                                return False
                            node = node[ch]
                        return self.end_of_word in node

                    def startsWith(self, prefix: str) -> bool:
                        """
                        Returns if there is any word in the trie that starts with the given prefix.
                        """
                        node = self.root
                        for ch in prefix:
                            if ch not in node:
                                return False
                            node = node[ch]
                        return True

                # Your Trie object will be instantiated and called as such:
                # obj = Trie()
                # obj.insert(word)
                # param_2 = obj.search(word)
                # param_3 = obj.startsWith(prefix)

2. Trie树实战题目解析：单词搜索2
   * 79. 单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

3. 并查集的基本实现、特性和实战题目解析:
    * 作用：看看两个元素是不是在同一个集合中，也可以合并两个集合
    * 操作： • makeSet(s):建立一个新的并查集，其中包含 s 个单元素集合。
            • unionSet(x, y):把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在
的集合不相交，如果相交则不合并。
            • find(x):找到元素 x 所在的集合的代表，该操作也可以用于判断两个元 素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。
    * 代码模版：

                def init(p):
                    # for i = 1,2,...: p[i] = i
                    p = [i for i in range(n)]
                def union(p, i, j):
                    p1 = parent(p, i)
                    p2 = parent(p, j)
                    p[p1] = p2
                def parent(p, i):
                    root = i
                    while p[root] != root:
                        root = p[root]
                    while p[i] != i: # 路径压缩
                        x = i; i = p[i]; p[x] = root
                    return root
### 第14课 字典树和并查集：
1. 剪枝的实现和特性:
   * DFS代码模版：

                # 递归：
                visited = set()
                def dfs(node, visited):
                    if node in visited: # terminator
                        return None
                    visited.add(node)
                    # process current node
                    for next_node in node.children():
                        if next_node not in visited:
                            dfs(next_node, visited)

                # 非递归：
                def dfs(root):
                    if root is None:
                        return []
                    visited, stack = [], []
                    while stack:
                        node = stack.pop()
                        visited.append(node)
                        process(node)
                        nodes = generate_related_nodes(node)
                        stack.append(nodes)
                    # other processing

    * BFS代码模版：

                def BFS(graph, start, end):
                    queue = []
                    queue.append([start])
                    visited.add(start)

                    while queue:
                        node = queue.pop(0)
                        visited.add(node)
                        
                        process(node)
                        nodes = generate_related_nodes(node)
                        queue.append(nodes)
    * 回溯法：回溯法采用试错的思想，它尝试分步的去解决一个问题。
2. 剪枝实战题目解析：数独
3. 双向BFS的实现、特性和题解:
   * 双向BFS代码模版：

                def two_ended_BFS(graph, start, end):
                    # using set:
                    front = {start}
                    back = {end}
                    # BFS starts:
                    while front:
                        next_front = set()
                        for node in front:
                            next_node = process(node)
                            if next_node in back:
                                return 
                            if next_node in graph:
                                next_front.add(next_node)
                                graph.remove(next_node)
                        front = next_front
                    if len(front) > len(back):
                        front, back = back, front

4. 启发式搜索(A*搜索)的实现、特性和题解:
    * 启发式函数: h(n)，它用来评价哪些结点最有希望的是一个我们要找的结 点，h(n) 会返回一个非负实数,也可以认为是从结点n的目标结点路径的估 计成本。启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测 哪个邻居结点会导向一个目标。
    * 773.滑动谜题（微软、谷歌、Facebook 在半年内面试中考过）:https://leetcode-cn.com/problems/sliding-puzzle/
    * A* 代码模版：

                def AstarSearch(graph, start, end):
                    pq = collections.priority_queue()
                    pq.append([start])
                    visited = set(start)

                    while pq:
                        node = pq.pop() # We can add more intelligence here
                        visited.add(node)

                        process(node)
                        nodes = generate_related_nodes(node)
                        unvisited = [node for node in nodes not in visited]
                        pq.push(unvisited)
    >参考链接
    >A* 代码模板: https://shimo.im/docs/8CzMlrcvbWwFXA8r
    >相似度测量方法:https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/
    >二进制矩阵中的最短路径的 A* 解法:https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python
    >8 puzzles 解法比较:https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/

### 第15课 AVL树和红黑树：
1. AVL树和红黑树的实现和特性:
    * AVL树：
      1. 发明者 G. M. Adelson-Velsky 和 Evgenii Landis
      2. Balance Factor(平衡因子): 是它的左子树的高度减去它的右子树的高度(有时相反)。 balancefactor={-1, 0, 1}
      3. 通过旋转操作来进行平衡(四种)
      4. https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree
    * AVL 旋转操作：
      1. 左旋 2. 右旋 3. 左右旋 4. 右左旋
    * AVL 旋转操作-- 图解：
        ![avatar](AVL.png)
    * RedBlack Tree:
        红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一 个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉 搜索树:
        • 每个结点要么是红色，要么是黑色
        • 根结点是黑色
        • 每个叶结点(NIL结点，空结点)是黑色的。
        • 不能有相邻接的两个红色结点
        • 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
    * RedBlack Tree VS. AVL:
        • AVL trees provide faster lookups than Red Black Trees because they are more strictly balanced.
        • Red Black Trees provide faster insertion and removal operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.
        • AVL trees store balance factors or heights with each node, thus requires storage for an integer per node whereas Red Black Tree requires only 1 bit of information per node.
        • Red Black Trees are used in most of the language libraries
        like map, multimap, multisetin C++whereas AVL trees are used in databases where faster retrievals are required.

#### **Python语法注意：**
* dict: setdefault:

                # 如果node['a']存在，取出来，如果不存在创建node['a'] = {}
                node = {}
                node = node.setdefault('a', {})

---
## 第8周：
---
### 第16课 位运算：
1. 位运算基础及实战要点:
   * 位运算符：

                >> : 右移
                << : 左移
                ^ : 按位异或
                ~ : 按位取反
                & : 按位与
                | : 按位或
    * XOR-异或：

                异或:相同为 0，不同为 1。也可用“不进位加法”来理解。 异或操作的一些特点:
                x^0=x
                x^1s=~x //注意 1s = ~0
                x^(~x)=1s
                x^x=0
                c=a^b => a^c=b,b^c=a //交换两个数 a^b^c=a^(b^c)=(a^b)^c //associative
    * 指定位置的位运算：

                 1. 将x最右边的n位清零:x&(~0<<n)
                 2. 获取x的第n位值(0或者1):(x>>n)&1
                 3. 获取x的第n位的幂值:x&(1<<n)
                 4. 仅将第n位置为1:x|(1<<n)
                 5. 仅将第n位置为0:x&(~(1<<n))
                 6. 将x最高位至第n位(含)清零:x&((1<<n)-1)
    * 实战位运算：

                • 判断奇偶:
                x%2==1 —>(x&1)==1 x%2==0 —>(x&1)==0
                • x>>1—>x/2.
                即: x=x/2; —> x=x>>1;
                mid=(left+right)/2; —> mid=(left+right)>>1;
                • X=X&(X-1)清零最低位的1  # 常用
                • X&-X=>得到最低位的1  # 常用
                • X&~X=>0
2. 位运算实战题目解析:
    >参考链接
    N 皇后位运算代码示例:https://shimo.im/docs/YzWa5ZZrZPYWahK2
    实战题目 / 课后作业
    位 1 的个数（Facebook、苹果在半年内面试中考过）:https://leetcode-cn.com/problems/number-of-1-bits/
    2 的幂（谷歌、亚马逊、苹果在半年内面试中考过）:https://leetcode-cn.com/problems/power-of-two/
    颠倒二进制位（苹果在半年内面试中考过）:https://leetcode-cn.com/problems/reverse-bits/
    N 皇后（字节跳动、亚马逊、百度在半年内面试中考过）:https://leetcode-cn.com/problems/n-queens/description/
    N 皇后 II （亚马逊在半年内面试中考过）:https://leetcode-cn.com/problems/n-queens-ii/description/
    比特位计数（字节跳动、Facebook、MathWorks 在半年内面试中考过）:https://leetcode-cn.com/problems/counting-bits/description/

### 第17课 布隆过滤和LRU缓存：
1. 布隆过滤器的实现及应用：
    * Bloom Filter:一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索 一个元素是否在一个集合中。
    * 查询结果：不存在----一定不存在；存在----不一定存在；
    * 应用：
        1. 比特币网络
        2. 分布式系统(Map-Reduce) — Hadoop、search engine
        3. Redis 缓存
        4. 垃圾邮件、评论等的过滤
    * 简单的BloomFilter：

                from bitarray import bitarray
                import mmh3
                class BloomFilter:
                    def __init__(self, size, hash_num):
                        self.size = size
                        self.hash_num = hash_num
                        self.bit_array = bitarray(size)
                        self.bit_array.setall(0)
                    
                    def add(self, s):
                        for seed in range(self.hash_num):
                            result = mmh3.hash(s, seed) % self.size
                            self.bit_array[result] = 1
                    
                    def lookup(self, s):
                        for seed in range(self.hash_num):
                            result = mmh3.hash(s, seed) % self.size
                            if self.bit_array[result] == 0:
                                return 'Nope'
                        return 'Probably'
                bf = BloomFilter(500000, 7)
                bf.add("dantezhao")
                bf.lookup("dantezhao")
    >参考链接
    布隆过滤器的原理和实现: https://www.cnblogs.com/cpselvis/p/6265825.html
    使用布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重: https://blog.csdn.net/tianyaleixiaowu/article/details/74721877
    布隆过滤器 Python 代码示例:https://shimo.im/docs/UITYMj1eK88JCJTH
    布隆过滤器 Python 实现示例: https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/
    高性能布隆过滤器 Python 实现示例:https://github.com/jhgg/pybloof
    布隆过滤器 Java 实现示例 1: https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java
    布隆过滤器 Java 实现示例 2:https://github.com/Baqend/Orestes-Bloomfilter
2. LRU Cache的实现、应用和题解:
    * LRU Cache：
        • 两个要素: 大小 、替换策略
        • Hash Table + Double LinkedList
        • O(1) 查询
        O(1) 修改、更新
    * LFU - least frequently used LRU - least recently used
    * 实现：

                class LRUCache:

                    def __init__(self, capacity: int):
                        self.dic = collections.OrderedDict()
                        self.remain = capacity

                    def get(self, key: int) -> int:
                        if key not in self.dic:
                            return -1
                        v = self.dic.pop(key)
                        self.dic[key] = v
                        return v

                    def put(self, key: int, value: int) -> None:
                        if key in self.dic:
                            self.dic.pop(key)
                        else:
                            if self.remain > 0:
                                self.remain -= 1
                            else:
                                self.dic.popitem(last = False)
                        self.dic[key] = value
    >参考链接
    Understanding the Meltdown exploit: https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/
    替换算法总揽: https://en.wikipedia.org/wiki/Cache_replacement_policies
    LRU Cache Python 代码示例:https://shimo.im/docs/CoyPAyXooGcDuLQo
    实战题目 / 课后作业
    LRU 缓存机制（亚马逊、字节跳动、Facebook、微软在半年内面试中常考）: https://leetcode-cn.com/problems/lru-cache/#/


### 第18课 排序算法：
1. 初级排序和高级排序的实现和特性
   * 快速排序：

                # 代码模版：
                class QuickSort:
                    def quickSort(self, begin, end, nums):
                        if begin >= end:
                            return
                        pivot = self._partition(begin, end, nums)
                        self.quickSort(begin, pivot - 1, nums)
                        self.quickSort(pivot + 1, end, nums)

                    def _partition(self, begin, end, nums):
                        pivot, counter = end, begin
                        for i in range(begin, end):
                            if nums[i] < nums[pivot]:
                                # 保持位置counter的值是第一个大于nums[pivot]的，counter左边的值都小于nums[pivot]
                                nums[i], nums[counter] = nums[counter], nums[i]
                                counter += 1
                        nums[counter], nums[pivot] = nums[pivot], nums[counter]
                        return counter

                a = [3,5,63,71,834,9,-34,5,-6,-7]
                q = QuickSort()
                q.quickSort(0, len(a)-1, a)
                print(a)
    * 归并排序：

                # 代码：
                class MergeSort:
                    def mergesort(self, nums, left, right):
                        if left >= right:
                            return None
                        mid = (left + right) >> 1
                        self.mergesort(nums, left, mid)
                        self.mergesort(nums, mid+1, right)
                        self._merge(nums, left, mid, right)

                    def _merge(self, nums, left, mid, right):
                        tmp = []
                        i, j = left, mid + 1
                        
                        while i <= mid and j <= right:
                            if nums[i] <= nums[j]:
                                tmp.append(nums[i])
                                i += 1
                            else:
                                tmp.append(nums[j])
                                j += 1
                        while i <= mid:
                            tmp.append(nums[i])
                            i += 1
                        while j <= right:
                            tmp.append(nums[j])
                            j += 1

                        nums[left:right+1] = tmp


                a = [3,5,4464,7,0,-498,9,4,-5,6,7]
                q = MergeSort()
                q.mergesort(a, 0, len(a)-1)
                print(a)
    * 堆排序：
  
                # 堆排序：
                import heapq
                class HeapSort:
                    def heapSort(self, nums):
                        heap = []
                        for n in nums:
                            heapq.heappush(heap, n)
                        for i in range(len(nums)):
                            nums[i] = heapq.heappop(heap)

                a = [3,5,6,-897,38,-9,4,5,633,7]
                q = HeapSort()
                q.heapSort(a)
                print(a)

    * 初级排序代码：

                # 冒泡排序：
                class BubbleSort:
                    def bubbleSort(self, nums):
                        n = len(nums)
                        for i in range(n):
                            for j in range(n-i-1):
                                if nums[j] > nums[j+1]:
                                    nums[j], nums[j+1] = nums[j+1], nums[j]

                # 选择排序：
                class SelectionSort:
                    def selectionSort(self, nums):
                        n = len(nums)
                        for i in range(n):
                            min_index = i
                            for j in range(i+1, n):
                                if nums[j] < nums[min_index]:
                                    min_index = j
                            nums[i], nums[min_index] = nums[min_index], nums[i]

                # 插入排序：
                class InsertionSort:
                    def insertionSort(self, nums):
                        n = len(nums)
                        pre_index = 0
                        current = 0
                        for i in range(1, n):
                            pre_index = i-1
                            current = nums[i]
                            while pre_index >= 0 and nums[pre_index] > current:
                                nums[pre_index+1] = nums[pre_index]
                                pre_index -= 1
                            nums[pre_index+1] = current

    >参考链接
    十大经典排序算法: https://www.cnblogs.com/onepixel/p/7674659.html
    快速排序代码示例:https://shimo.im/docs/TX9bDbSC7C0CR5XO
    归并排序代码示例:https://shimo.im/docs/sDXxjjiKf3gLVVAU
    堆排序代码示例:https://shimo.im/docs/M2xfacKvwzAykhz6
2. 特殊排序及实战题目详解:
    * 特殊排序:
        • 计数排序(Counting Sort) 计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存 储在额外开辟的数组空间中;然后依次把计数大于 1 的填充回原数组
        • 桶排序(Bucket Sort)
        桶排序 (Bucket sort)的工作的原理:假设输入数据服从均匀分布，将数据分到 有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方 式继续使用桶排序进行排)。
        • 基数排序(Radix Sort) 基数排序是按照低位先排序，然后收集;再按照高位排序，然后再收集;依次类 推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按 高优先级排序。
    * 逆数对和翻转对：
        * 翻转对、逆数对： 493. 翻转对：https://leetcode-cn.com/problems/reverse-pairs/
        * 剑指 Offer 51. 数组中的逆序对： https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/

    >参考链接
    十大经典排序算法:https://www.cnblogs.com/onepixel/p/7674659.html
    9 种经典排序算法可视化动画:https://www.bilibili.com/video/av25136272
    6 分钟看完 15 种排序算法动画展示:https://www.bilibili.com/video/av63851336
    实战题目 / 课后作业
    数组的相对排序（谷歌在半年内面试中考过）:https://leetcode-cn.com/problems/relative-sort-array/
    有效的字母异位词（Facebook、亚马逊、谷歌在半年内面试中考过）:https://leetcode-cn.com/problems/valid-anagram/
    力扣排行榜（此题选做；Bloomberg 在半年内面试中考过）:https://leetcode-cn.com/problems/design-a-leaderboard/
    合并区间（Facebook、字节跳动、亚马逊在半年内面试中常考）:https://leetcode-cn.com/problems/merge-intervals/
    翻转对（字节跳动在半年内面试中考过）:https://leetcode-cn.com/problems/reverse-pairs/

---
## 第9周：
---
### 第19课 高级动态规划：
1.动态规划、状态转移方程串讲：
  * 动态规划 Dynamic Programming:
      1. “Simplifying a complicated problem by breaking it down into simpler sub-problems”
      (in a recursive manner)
      2. Divide & Conquer + Optimal substructure 分治 + 最优子结构
      3. 顺推形式: 动态递推
  * DP 代码模版：

                function DP():
                    dp = [][] # 二维的情况
                    for i = 0 , ... , m:
                        for j = 0, ... , n:
                            df[i][j] = _function(dp[i'][j'])
                    return dp[m][n]

  * 不同路径 2 这道题目(https://leetcode-cn.com/problems/unique-paths-ii/)的状态转移方程:

        #   dp方程：
        if obstacleGrid[i] == 1:
          dp[i] = 0
        else:
          dp[i] = dp[i] + dp[i-1]

        # 代码：
        class Solution:
          def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
              dp = [0] * len(obstacleGrid[0])
              dp[0] = 1
              for row in obstacleGrid:
                  for i in range(len(row)):
                      if row[i] == 1:
                          dp[i] = 0
                      elif i > 0:
                          dp[i] += dp[i-1] 
              return dp[-1]
  * 股票问题系列通解:https://leetcode-cn.com/circle/article/qiAgHn/
  ![avatar](stock.png)

2. 高级动态规划题目详解:
   *  爬楼梯问题的延伸（https://leetcode-cn.com/problems/climbing-stairs/）：
      1. 增加：可以一次走3步；
      2. 增加：可以一次走n步（n为数列的形式表示）；
      3. 增加条件：不能走重复的步数。
   *  72. 编辑距离(https://leetcode-cn.com/problems/edit-distance/):
    ![avatar](Edit_distance.jpeg)

### 第20课 字符串算法：
1. 字符串基础知识和引申题目:
  >参考链接
  不可变字符串
  Atoi 代码示例
  >字符串基础问题
  转换成小写字母（谷歌在半年内面试中考过）
  最后一个单词的长度（苹果、谷歌、字节跳动在半年内面试中考过）
  宝石与石头（亚马逊在半年内面试中考过）
  字符串中的第一个唯一字符
  （亚马逊、微软、Facebook 在半年内面试中考过）
  字符串转换整数 (atoi) （亚马逊、微软、Facebook 在半年内面试中考过）
  >字符串操作问题
  最长公共前缀（亚马逊、谷歌、Facebook 在半年内面试中考过）
  反转字符串（亚马逊、谷歌、苹果在半年内面试中考过）
  反转字符串 II （亚马逊在半年内面试中考过）
  翻转字符串里的单词（微软、字节跳动、苹果在半年内面试中考过）
  反转字符串中的单词 III （微软、字节跳动、华为在半年内面试中考过）
  仅仅反转字母（字节跳动在半年内面试中考过）
  >异位词问题
  有效的字母异位词
  （Facebook、亚马逊、谷歌在半年内面试中考过）
  字母异位词分组（亚马逊在半年内面试中常考）
  找到字符串中所有字母异位词（Facebook 在半年内面试中常考）
  >回文串问题
  验证回文串（Facebook 在半年内面试中常考）
  验证回文字符串 Ⅱ（Facebook 在半年内面试中常考）
  最长回文子串（亚马逊、字节跳动、华为在半年内面试中常考）
2. 高级字符串算法:
  * 最长公共子序列--longest common sequence（1143. 最长公共子序列：https://leetcode-cn.com/problems/longest-common-subsequence/）：

        # DP转移方程(有强传递关系)：
        m = len(text1)
        n = len(text2)
        dp = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m):
          for j in range(1, n):
            if text1[i-1] == text2[j-1]:
              dp[i][j] = dp[i-1][j-1] + 1
            else:
              dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]

  * 最长公共子串----longest common substring：

        # DP转移方程(有弱传递关系，只在对角线上有传递关系，返回最大值)：
        m = len(text1)
        n = len(text2)
        dp = [[0] * (n+1) for _ in range(m+1)]
        for i in range(1, m):
          for j in range(1, n):
            if text1[i-1] == text2[j-1]:
              dp[i][j] = dp[i-1][j-1] + 1
            else:
              dp[i][j] = 0
        return max(dp)  ##重点关注
    **DP转移方程(有弱传递关系，只在对角线上有传递关系，返回最大值)**
  *  最长回文子串(https://leetcode-cn.com/problems/longest-palindromic-substring/):
      1. 暴力（O(n^3)）
      2. 枚举中心，两边扩散O(n^2)：
      3. DP方程:

        P(i, j) = True s[i,j]是回文；
                  Fasle s[i, j]不是回文。（s[i,j]指i，j的闭区间）
        P(i, j) = P(i+1, j-1) && s[i] == s[j]
  * 10. 正则表达式匹配: https://leetcode-cn.com/problems/regular-expression-matching/

        # 暴力递归：
        class Solution:
            def isMatch(self, s: str, p: str) -> bool:
                if not p: return not s
                
                first = bool(s) and p[0] in {s[0], '.'}
                
                if len(p) >= 2 and p[1] == '*':
                    return self.isMatch(s, p[2:]) or (first and self.isMatch(s[1:], p))
                else:
                    return first and self.isMatch(s[1:], p[1:])

        # 记忆递归：
        class Solution:
            def isMatch(self, s: str, p: str) -> bool:
                memo = {}
                
                def dp(i, j):
                    if (i, j) in memo: return memo[(i, j)]
                    if j == len(p): return i == len(s)
                    
                    first = i < len(s) and p[j] in {s[i], '.'}
                    
                    if len(p) - j >= 2 and p[j+1] == '*':
                        ans = dp(i, j+2) or (first and dp(i+1, j))
                    else:
                        ans = first and dp(i+1, j+1)
                        
                    memo[(i, j)] = ans
                    return ans
                
                return dp(0, 0)
  > 参考资料：
    最长子串、子序列问题
    最长公共子序列（亚马逊、字节跳动、谷歌在半年内面试中考过）：https://leetcode-cn.com/problems/longest-common-subsequence/
    编辑距离（亚马逊、字节跳动、谷歌在半年内面试中考过）：https://leetcode-cn.com/problems/edit-distance/
    最长回文子串（亚马逊、华为、字节跳动在半年内面试常考）：https://leetcode-cn.com/problems/longest-palindromic-substring/
    字符串 +DP 问题
    正则表达式匹配（Facebook、微软、字节跳动在半年内面试中考过）：https://leetcode-cn.com/problems/regular-expression-matching/
    题解： https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/
    通配符匹配（Facebook、微软、字节跳动在半年内面试中考过）：https://leetcode-cn.com/problems/wildcard-matching/
    不同的子序列（MathWorks 在半年内面试中考过）：https://leetcode-cn.com/problems/wildcard-matching/
3. 字符串匹配算法：
  * 暴力法（brute force）O(mn);
  * Rabin-Karp
  * KMP
  >参考链接
  Boyer-Moore 算法: https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.
  Sunday 算法: https://blog.csdn.net/u012505432/article/details/52210975
  字符串匹配暴力法代码示例: https://shimo.im/docs/8G0aJqNL86wWrPUE
  Rabin-Karp 代码示例: https://shimo.im/docs/1wnsM7eaZ6Ab9j9M
  KMP 字符串匹配算法视频: https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171
  字符串匹配的 KMP 算法: http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

#### **需要理解的地方：**
* 最长公共前缀(https://leetcode-cn.com/problems/longest-common-prefix/description/),如何用Trie实现
* 300. 最长上升子序列https://leetcode-cn.com/problems/longest-increasing-subsequence/:题解：https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation
        def lengthOfLIS(self, nums):
            tails = [0] * len(nums)
            size = 0
            for x in nums:
                i, j = 0, size
                while i != j:
                    m = (i + j) / 2
                    if tails[m] < x:
                        i = m + 1
                    else:
                        j = m
                tails[i] = x
                size = max(i + 1, size)
            return size

#### **疑问：**
* 如何改进下面的超时题解： 44. 通配符匹配： https://leetcode-cn.com/problems/wildcard-matching/

        class Solution:
            def isMatch(self, s: str, p: str) -> bool:
                memo = {}
                if not s and not p: return True
                
                def dp(i, j):
                    if (i, j) in memo: return memo[(i, j)]
                    if j == len(p): return i == len(s)
                    
                    first = len(s) > i and p[j] in [s[i], '?']
                    
                    if len(p) > j and p[j] == '*':
                        ans = False
                        for k in range(i, len(s)+1):
                            ans = ans or dp(k, j+1)
                    else:
                        ans = first and dp(i+1, j+1)
                    memo[(i, j)] = ans
                    
                    return ans
                
                return dp(0, 0)

#### **漂亮代码收集：**
*  297. 二叉树的序列化与反序列化序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。(https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

               # Definition for a binary tree node.
               # class TreeNode(object):
               #     def __init__(self, x):
               #         self.val = x
               #         self.left = None
               #         self.right = None

               class Codec:

                  def serialize(self, root):
                     """Encodes a tree to a single string.
                     
                     :type root: TreeNode
                     :rtype: str
                     """
                     def doit(node):
                           if node:
                              vals.append(str(node.val))
                              doit(node.left)
                              doit(node.right)
                           else:
                              vals.append('#')
                     
                     vals = []
                     doit(root)
                     return ' '.join(vals)

                  def deserialize(self, data):
                     """Decodes your encoded data to tree.
                     
                     :type data: str
                     :rtype: TreeNode
                     """
                     def doit():
                           val = next(vals)  ##使用了迭代器，漂亮！！
                           if val == '#':
                              return None
                           node = TreeNode(int(val))
                           node.left = doit()
                           node.right = doit()
                           return node
                     
                     vals = iter(data.split())
                     return doit()
                     

               # Your Codec object will be instantiated and called as such:
               # ser = Codec()
               # deser = Codec()
               # ans = deser.deserialize(ser.serialize(root))
   *  236. 二叉树的最近公共祖先
      给定一个二叉树, 找到该树中两个指定节点的最近公共祖先.百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]::https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
      
               # Definition for a binary tree node.
               # class TreeNode:
               #     def __init__(self, x):
               #         self.val = x
               #         self.left = None
               #         self.right = None

               class Solution:
                  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
                     if root in (None, p, q):
                           return root
                     left , right = (self.lowestCommonAncestor(kid, p, q)
                                       for kid in (root.left, root.right))
                     return root if left and right else left or right
   * 77. 组合,给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

                class Solution:
                def combine(self, n: int, k: int) -> List[List[int]]:
                    res = []
                    self.dfs([i for i in range(1, n+1)], k, [], res)
                    return res
                
                def dfs(self, nums, k, path, res):
                    if len(path) == k:
                            res.append(path)
                            return
                  
                  # 组合：
                  for i in range(len(nums)):
                        dfs(nums[i+1:], k, path+[nums[i]], res)  ## dfs-深度优先，也就是递归
                        ## 技术要点是`path+[nums[i]]`和`nums[i+1:]`
                  
                  ## 全排列：
                  for i in range(len(nums)):
                     if nums[i] not in path:
                        self.dfs(nums, n, path+[nums[i]], res)
   * 78. 子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。
   可用：递归、组合的思路、迭代

                class Solution:
                def subsets(self, nums: list) -> list:
                    res = []
                    self.dfs(nums, [], 0, res)
                    return res
                
                def dfs(self, nums, path, index, res):
                    if index == len(nums):
                            res.append(path)
                            return
                    
                  self.dfs(nums, path.copy(), index+1, res)
                  
                  path.append(nums[index])
                  
                  self.dfs(nums, path.copy(), index+1, res)
                  
                s = Solution()
                print(s.subsets([1,2,3]))
      >##### 可以理解为三个格子，分别各自放1，2，3还是空格的组合
      >##### path.copy():表示只传path的各自复制引用，否则path的所有改变最终都只res.append(path)中显现。
   * 51.  n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击上图为 8 皇后问题的一种解法。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。链接：https://leetcode-cn.com/problems/n-queens

               class Solution:
                  def solveNQueens(self, n: int) -> List[List[str]]:
                     def DFS(queens: list, pie: list, na: list):
                           '''
                           queens: 各行queens所在的位置组成的数列；
                           pie: 撇，存放左斜位置的数列；
                           na: 捺， 存放右斜位置的数列。
                           '''
                           
                           # 当前行数：
                           row = len(queens)
                           if row == n:
                              results.append(queens)
                              return None
                           for col in range(n):
                              if col not in queens and row+col not in pie and row-col not in na:
                                 DFS(queens+[col], pie+[row+col], na+[row-col])
                     
                     results = []
                     DFS([], [], [])
                     return [[f'{"."*i}Q{"."*(n-i-1)}' for i in res] for res in results]

* 55. 跳跃游戏
   给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。示例 1:
   输入: [2,3,1,1,4]
   输出: true
   解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

            # 使用贪心算法：
            class Solution:
               def canJump(self, nums: List[int]) -> bool:
                  if not nums:
                        return False
                  reachable_end = len(nums) - 1
                  for i in range(len(nums)-1, -1, -1):
                        if nums[i] + i >= reachable_end:
                           reachable_end = i
                  if reachable_end == 0:
                        return True
                  else:
                        return False

 * 45. 跳跃游戏 II 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。

            class Solution:
               def jump(self, nums: List[int]) -> int:
                  maxPos, step, end = 0, 0, 0
                  for i in range(len(nums)-1): # 注意:len(nums)-1
                        if maxPos >= i:
                           maxPos = max(nums[i]+i, maxPos)
                           if i == end:
                              step += 1
                              end = maxPos
                  return step
   **注意:len(nums)-1**
 * 127. 单词接龙给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。

            # BFS:
            from collections import defaultdict
            class Solution:
               def ladderLength(self, beginWord: str, endWord: str, wordList: list) -> int:
                  if endWord not in wordList or not beginWord or not wordList:
                        return 0
                  
                  L = len(beginWord)
                  all_combo_dict = defaultdict(list)

                  for word in wordList:
                        for i in range(L):
                           all_combo_dict[word[:i]+'*'+word[i+1:]].append(word)

                  queue = [(beginWord, 1)]
                  visited = set()
                  visited.add(beginWord)

                  while queue:
                        current_word , level = queue.pop(0)
                        for i in range(L):
                           intermediate_word = current_word[:i]+'*'+current_word[i+1:]
                           for word in all_combo_dict[intermediate_word]:
                              if word == endWord:
                                    return level + 1
                              if word not in visited:
                                    visited.add(word)
                                    queue.append((word, level+1))
                           all_combo_dict[intermediate_word] = []

                  return 0

 * 126. 单词接龙 II https://leetcode-cn.com/problems/word-ladder-ii/ ;给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：每次转换只能改变一个字母.转换后得到的单词必须是字典中的单词。说明:如果不存在这样的转换序列，返回一个空列表。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

            class Solution:
               def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
                  
                  if endWord not in  wordList or not beginWord or not wordList:
                        return []
                  
                  wordList = set(wordList)
                  res = []
                  layer = {}
                  layer[beginWord] = [[beginWord]]
                  
                  while layer:
                        newlayer = collections.defaultdict(list)
                        for w in layer:
                           if w == endWord:
                              res.extend(k for k in layer[w])
                           else:
                              for i in range(len(w)):
                                    for c in 'abcdefghijklmnopqrstuvwxyz':
                                       neww = w[:i] + c + w[i+1:]
                                       if neww in wordList:
                                          newlayer[neww] += [j + [neww] for j in layer[w]]
                        wordList -= set(newlayer.keys())
                        layer = newlayer
                        
                  return res

 * 529. 扫雷游戏 https://leetcode-cn.com/problems/minesweeper/ 让我们一起来玩扫雷游戏！

            # 529. 扫雷游戏
            # https://leetcode-cn.com/problems/minesweeper/
            # 让我们一起来玩扫雷游戏！

            # 给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。

            # 现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：

            # 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。
            # 如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露。
            # 如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
            # 如果在此次点击中，若无更多方块可被揭露，则返回面板。

            class Solution:
               def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
                  if not board:
                        return []
                  
                  i, j = click[0], click[1]
                  
                  if board[i][j] == 'M':
                        board[i][j] = 'X'
                        return board
                  
                  self.dfs(board, i, j)
                  
                  return board
               
               def dfs(self, board, i, j):
                  if board[i][j] != 'E':
                        return None
                  
                  rows, cols = len(board), len(board[0])
                  directions = [(0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1)]
                  mine_count = 0
                  
                  for d in directions:
                        ni, nj = i + d[0], j + d[1]
                        if 0 <= ni < rows and 0 <= nj < cols and board[ni][nj] == 'M':
                           mine_count += 1
                           
                  if mine_count == 0:
                        board[i][j] = 'B'
                        
                  else:
                        board[i][j] = str(mine_count)
                        return None
                  
                  for d in directions:
                        ni, nj = i + d[0], j + d[1]
                        if 0 <= ni < rows and 0 <= nj < cols:
                           self.dfs(board, ni, nj)

* 36. 有效的数独:判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可.数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

                class Solution:
                    def isValidSudoku(self, board: List[List[str]]) -> bool:
                        rows = [{} for _ in range(9)]
                        columns = [{} for _ in range(9)]
                        boxes = [{} for _ in range(9)]
                        
                        for i in range(9):
                            for j in range(9):
                                if board[i][j] != '.':
                                    num = int(board[i][j])
                                    box_index = i // 3 * 3 + j // 3
                                    
                                    rows[i][num] = rows[i].get(num, 0) + 1
                                    columns[j][num] = columns[j].get(num, 0) + 1
                                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1
                                    
                                    if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1:
                                        return False
                        
                        return True


4.  找到字符串中所有字母异位词: https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/

        class Solution:
            def findAnagrams(self, s: str, p: str) -> List[int]:
                if not s or not p: return None
                res = []
                p_dict = {}
                win_dict = {}
                
                for c in p:
                    p_dict[c] = p_dict.get(c, 0) + 1
                    
                len_s, len_p = len(s), len(p)
                left, right = 0, 0
                while right < len_s:
                    c = s[right]
                    if c not in p_dict:
                        win_dict.clear()
                        left = right = right + 1
                    else:
                        win_dict[c] = win_dict.get(c, 0) + 1
                        if right - left + 1 == len_p:
                            if win_dict == p_dict:
                                res.append(left)
                            win_dict[s[left]] -= 1
                            left += 1
                        right += 1
                
                return res